// Core Jet Framework Class
// Main application class with essential functionality

import { Console } from "console"
import { Router } from "../router/Router.soul"
import { MiddlewareManager } from "../middleware/MiddlewareManager.soul"
import { HtmlRenderer } from "../utils/HtmlRenderer.soul"

sanctuary Jet {
    soul __genesis__(port) {
        if (port) {
            this.port = port
        } else {
            this.port = 8888
        }
        
        // Core properties
        this.server = null
        this.startTime = null
        
        // Component managers
        this.router = Router.new()
        this.middlewareManager = MiddlewareManager.new()
        this.htmlRenderer = HtmlRenderer()
        
        // Settings
        this.settings = {
            env: "development",
            trustProxy: false,
            jsonLimit: "10mb",
            urlEncoded: true
        }
        
        // Enhanced architecture components
        this.controllers = {}
        this.services = {}
        this.repositories = {}
        this.models = {}
        this.config = {}
        
        // Performance tracking
        this.performance = {
            startTime: 0,
            requests: 0,
            errors: 0,
            avgResponseTime: 0
        }
        
        // Initialize logger
        this.initializeLogger()
    }

    // Initialize logger
    soul initializeLogger() {
        this.logger = {
            info: soul(message) { Console.log("[INFO] " + message) },
            warn: soul(message) { Console.log("[WARN] " + message) },
            error: soul(message) { Console.log("[ERROR] " + message) },
            debug: soul(message) { 
                if (this.settings.env == "development") {
                    Console.log("[DEBUG] " + message)
                }
            }
        }
    }

    // Configuration methods
    soul set(key, value) {
        this.settings[key] = value
        return this
    }

    soul get(key) {
        return this.settings[key]
    }
    
    // Method to set start time
    soul setStartTime(timestamp) {
        this.startTime = timestamp
        return this
    }

    soul env(environment) {
        this.settings.env = environment
        return this
    }

    soul trust(proxy) {
        this.settings.trustProxy = proxy
        return this
    }
    
    // View engine configuration
    soul setViewsPath(path) {
        // Always try to resolve to executable directory first
        execDir = os.executableDir()
        execRelativePath = os.joinPath(execDir, path)
        
        resolvedPath = path
        if (os.exists(execRelativePath)) {
            resolvedPath = execRelativePath
        }
        
        this.htmlRenderer.setViewsPath(resolvedPath)
        return this
    }
    
    soul setDefaultLayout(layout) {
        this.htmlRenderer.setDefaultLayout(layout)
        return this
    }
    
    soul enableViewCache(enable) {
        this.htmlRenderer.enableCache(enable)
        return this
    }
    
    soul helper(name, helperFunction) {
        this.htmlRenderer.helper(name, helperFunction)
        return this
    }
    
    // Enhanced architecture registration methods
    soul registerController(name, controller) {
        this.controllers[name] = controller
        if (controller.setApp) {
            controller.setApp(this)
        }
        return this
    }
    
    soul registerService(name, service) {
        this.services[name] = service
        if (service.setApp) {
            service.setApp(this)
        }
        return this
    }
    
    soul registerRepository(name, repository) {
        this.repositories[name] = repository
        if (repository.setApp) {
            repository.setApp(this)
        }
        return this
    }
    
    soul registerModel(name, model) {
        this.models[name] = model
        return this
    }
    
    soul getController(name) {
        if (!this.controllers) {
            return null
        }
        
        return this.controllers[name]
    }
    
    soul getService(name) {
        if (!this.services) {
            return null
        }
        return this.services[name]
    }
    
    soul getRepository(name) {
        return this.repositories[name]
    }
    
    soul getModel(name) {
        return this.models[name]
    }

    // Middleware delegation
    soul use(middleware) {
        return this.middlewareManager.use(middleware, null, this)
    }

    // Advanced middleware methods
    soul cors(options) {
        return this.middlewareManager.cors(options, this)
    }

    soul helmet(options) {
        return this.middlewareManager.helmet(options, this)
    }

    soul compression(options) {
        return this.middlewareManager.compression(options, this)
    }

    soul rateLimit(options) {
        return this.middlewareManager.rateLimit(options, this)
    }

    soul auth(strategy, options) {
        return this.middlewareManager.auth(strategy, options, this)
    }

    soul json(options) {
        return this.middlewareManager.json(options, this)
    }

    soul urlencoded(options) {
        return this.middlewareManager.urlencoded(options, this)
    }

    // Enhanced static file serving
    soul static(urlPath, localPath) {
        // Ensure server is created before registering static files
        if (!this.server) {
            this.server = http.createServer(this.port)
        }
        
        // Pass the path through - the web server will resolve it
        resolvedPath = localPath
        
        // Simple default options
        options = {
            index: ["index.html", "index.htm"],
            dotfiles: "ignore",
            etag: true,
            extensions: ["html", "htm"],
            fallthrough: true,
            immutable: false,
            lastModified: true,
            maxAge: 0,
            redirect: true,
            setHeaders: null
        }
        
        // Register wildcard route for static files
        staticUrlPath = urlPath
        
        // If path already has /*, use it as-is
        // If path ends with *, convert to /* 
        // If path has no wildcard, add /*
        if (staticUrlPath.includes("/*")) {
            // Path already has /* wildcard
        } else if (staticUrlPath.charAt(staticUrlPath.length() - 1) == "*") {
            staticUrlPath = staticUrlPath.substring(0, staticUrlPath.length() - 1) + "/*"
        } else {
            staticUrlPath = staticUrlPath + "/*"
        }
        
        console.log("‚úÖ Registering static route: " + staticUrlPath + " -> " + resolvedPath)
        
        // Register with Soul's web server for static file handling
        // Use the original path (without wildcard) for Soul's static method
        cleanPath = urlPath
        if (cleanPath.endsWith("/*")) {
            cleanPath = cleanPath.substring(0, cleanPath.length() - 2)
        }
        
        try {
            if (this.server && this.server.static) {
                this.server.static(cleanPath, resolvedPath)
            }
        } catch (error) {
            console.log("‚ùå Error calling server.static(): " + error)
        }
        
        // Also register with Jet router as fallback
        this.get(staticUrlPath, soul(req, res) {
            console.log("üéØ Static file request matched: " + req.path + " via pattern: " + staticUrlPath)
            this.serveStaticFile(req, res, urlPath, resolvedPath, options)
        })
        
        // Also add debugging to see what patterns we're registering
        
        return this
    }
    
    // Static file serving implementation
    soul serveStaticFile(req, res, urlPath, localPath, options) {
        try {
            requestPath = req.path
            
            // Remove URL prefix to get relative file path
            if (requestPath.startsWith(urlPath)) {
                relativePath = requestPath.substring(urlPath.length())
                
                // Remove leading slash
                if (relativePath.startsWith("/")) {
                    relativePath = relativePath.substring(1)
                }
            } else {
                relativePath = requestPath
            }
            
            // Security: prevent directory traversal
            if (relativePath.includes("..") || relativePath.includes("~")) {
                console.log("‚ùå Directory traversal blocked: " + relativePath)
                res.status(403).send("Forbidden")
                return
            }
            
            // Construct full file path
            fullPath = localPath + "/" + relativePath
            
            console.log("üìÑ Serving: " + requestPath + " -> " + fullPath)
            
            // Read file
            content = io.read(fullPath)
            
            // Get file extension and MIME type
            extension = this.getFileExtension(relativePath)
            mimeType = this.getMimeType(extension)
            
            // Set headers
            res.header("Content-Type", mimeType)
            
            // Cache headers based on environment
            if (this.settings.env == "development") {
                res.header("Cache-Control", "no-cache, no-store, must-revalidate")
                res.header("Pragma", "no-cache")
                res.header("Expires", "0")
            } else {
                res.header("Cache-Control", "public, max-age=31536000")
                res.header("ETag", '"' + content.length() + '"')
            }
            
            // Security headers
            res.header("X-Content-Type-Options", "nosniff")
            
            res.send(content)
            
        } catch (error) {
            console.log("‚ùå Static file error: " + error)
            res.status(404).send("Not Found")
        }
    }
    
    // Helper to get file extension
    soul getFileExtension(filePath) {
        if (!filePath || filePath.length() == 0) {
            return ""
        }
        
        lastDotIndex = filePath.lastIndexOf(".")
        if (lastDotIndex == -1) {
            return ""
        }
        
        return filePath.substring(lastDotIndex + 1).toLowerCase()
    }
    
    // Helper to get MIME type
    soul getMimeType(extension) {
        mimeTypes = {
            "css": "text/css; charset=utf-8",
            "js": "application/javascript; charset=utf-8",
            "html": "text/html; charset=utf-8",
            "htm": "text/html; charset=utf-8",
            "json": "application/json; charset=utf-8",
            "png": "image/png",
            "jpg": "image/jpeg",
            "jpeg": "image/jpeg",
            "gif": "image/gif",
            "svg": "image/svg+xml",
            "ico": "image/x-icon",
            "webp": "image/webp",
            "woff": "font/woff",
            "woff2": "font/woff2",
            "ttf": "font/ttf",
            "otf": "font/otf",
            "txt": "text/plain; charset=utf-8",
            "pdf": "application/pdf",
            "zip": "application/zip"
        }
        
        if (mimeTypes[extension]) {
            return mimeTypes[extension]
        }
        
        return "application/octet-stream"
    }

    soul error(handler) {
        return this.middlewareManager.error(handler, this)
    }

    // Route delegation
    soul route(method, path, handlers) {
        return this.router.route(method, path, handlers, this)
    }

    // HTTP method shortcuts
    soul get(path, handlers) {
        return this.route("GET", path, handlers)
    }

    soul post(path, handlers) {
        return this.route("POST", path, handlers)
    }

    soul put(path, handlers) {
        return this.route("PUT", path, handlers)
    }

    soul patch(path, handlers) {
        return this.route("PATCH", path, handlers)
    }

    soul delete(path, handlers) {
        return this.route("DELETE", path, handlers)
    }

    soul options(path, handlers) {
        return this.route("OPTIONS", path, handlers)
    }

    soul head(path, handlers) {
        return this.route("HEAD", path, handlers)
    }

    soul all(path, handlers) {
        methods = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"]
        for (i = 0; i < methods.length(); i = i + 1) {
            this.route(methods[i], path, handlers)
        }
        return this
    }
    
    // Template rendering helper
    soul render(templateName, data, options) {
        return this.htmlRenderer.render(templateName, data, options)
    }
    
    soul renderString(template, data) {
        return this.htmlRenderer.renderString(template, data)
    }
    
    // Enhanced routing with controller integration
    soul controller(controllerName, methodName) {
        console.log("üîç [CONTROLLER SETUP] Creating controller wrapper for " + controllerName + "." + methodName)
        console.log("üîç [CONTROLLER SETUP] this: " + this)
        console.log("üîç [CONTROLLER SETUP] this.controllers: " + this.controllers)
        
        // Capture the app context
        app = this
        
        return soul(req, res, next) {
            console.log("üîç [CONTROLLER] " + controllerName + "." + methodName + " called")
            console.log("üîç [CONTROLLER] app context: " + app)
            console.log("üîç [CONTROLLER] app.controllers: " + app.controllers)
            
            try {
                // Safely get controller with null checks
                if (!controllerName) {
                    return res.status(500).json({
                        error: "Internal Server Error",
                        message: "Invalid controller name"
                    })
                }
                
                if (!methodName) {
                    return res.status(500).json({
                        error: "Internal Server Error",
                        message: "Invalid method name"
                    })
                }
                
                console.log("üîç [CONTROLLER] Getting controller: " + controllerName)
                controller = app.getController(controllerName)
                console.log("üîç [CONTROLLER] Controller retrieved: " + controller)
                
                if (!controller) {
                    console.log("‚ùå [CONTROLLER] Controller not found: " + controllerName)
                    return res.status(500).json({
                        error: "Internal Server Error",
                        message: "Controller '" + controllerName + "' not found"
                    })
                }
                
                console.log("üîç [CONTROLLER] Checking if method exists: " + methodName)
                
                // For Soul class instances, we need to call methods directly
                // We can't use bracket notation to access methods dynamically
                console.log("üîç [CONTROLLER] Calling method directly on controller instance")
                
                if (!controller) {
                    console.log("‚ùå [CONTROLLER] Controller is null")
                    return res.status(500).json({
                        error: "Internal Server Error", 
                        message: "Controller '" + controllerName + "' is null"
                    })
                }
                
                // Call controller method safely - use conditional for known methods
                console.log("üîç [CONTROLLER] About to call method: " + methodName)
                
                if (methodName == "login") {
                    console.log("üîç [CONTROLLER] Calling login method")
                    controller.login(req, res)
                } else if (methodName == "register") {
                    console.log("üîç [CONTROLLER] Calling register method")
                    controller.register(req, res)
                } else if (methodName == "verify") {
                    console.log("üîç [CONTROLLER] Calling verify method")
                    controller.verify(req, res)
                } else {
                    console.log("‚ùå [CONTROLLER] Unknown method: " + methodName)
                    return res.status(500).json({
                        error: "Internal Server Error",
                        message: "Method '" + methodName + "' not supported"
                    })
                }
                
                console.log("üîç [CONTROLLER] method call completed")
                
            } catch (error) {
                console.log("‚ùå Controller error: " + error)
                return res.status(500).json({
                    error: "Internal Server Error",
                    message: "Error executing controller method"
                })
            }
        }
    }

    // Server lifecycle
    soul listen(callback) {
        // Use existing server if created, otherwise create new one
        if (!this.server) {
            this.server = http.createServer(this.port)
        }
        app = this
        
        // Register routes directly with the HTTP server
        this.router.registerRoutes(this.server)
        
        this.logger.info("üöÄ Jet server starting on port " + this.port)
        this.logger.info("üìç Environment: " + this.settings.env)
        this.logger.info("üåê Visit: http://localhost:" + this.port)
        
        if (callback) {
            callback()
        }
        
        // Start server and keep it running (this blocks)
        this.server.listen()
        
        return this
    }

    // Health check
    soul health() {
        return {
            status: "healthy",
            uptime: time.now() - this.startTime,
            requests: this.performance.requests,
            errors: this.performance.errors,
            avgResponseTime: this.performance.avgResponseTime,
            version: "1.0.0"
        }
    }
}

// Factory function to create Jet instances
soul createJet(port) {
    return Jet.new(port)
}