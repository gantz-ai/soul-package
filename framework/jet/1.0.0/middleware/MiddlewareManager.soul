// MiddlewareManager - Handles middleware registration and execution
// Separated middleware logic from main Jet class

import { Console } from "console"

sanctuary MiddlewareManager {
    soul __genesis__() {
        this.middlewares = []
        this.errorHandlers = []
        this.defaultConfigs = this.initializeDefaultConfigs()
    }

    // Initialize default configurations for middleware
    soul initializeDefaultConfigs() {
        return {
            cors: {
                origin: "*",
                methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
                headers: ["Content-Type", "Authorization"],
                credentials: false,
                maxAge: 86400,
                preflightContinue: false
            },
            helmet: {
                contentSecurityPolicy: true,
                frameguard: true,
                hidePoweredBy: true,
                noSniff: true,
                xssFilter: true
            },
            compression: {
                level: 6,
                threshold: 1024,
                filter: null
            },
            rateLimit: {
                windowMs: 900000,
                max: 100,
                message: "Too many requests"
            },
            staticFiles: {
                index: "index.html",
                dotfiles: "ignore",
                etag: true,
                extensions: false,
                fallthrough: true,
                immutable: false,
                lastModified: true,
                maxAge: 0,
                redirect: true,
                setHeaders: null
            }
        }
    }

    // Middleware system
    soul use(middleware, unused, app) {
        // Add middleware to apply to all paths
        this.middlewares.push({
            path: "*",
            handler: middleware,
            type: "middleware"
        })
        return app
    }

    // Helper method to merge options with defaults
    soul mergeWithDefaults(key, options) {
        if (key == "cors") {
            return {
                origin: options && options.origin ? options.origin : "*",
                methods: options && options.methods ? options.methods : ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
                headers: options && options.headers ? options.headers : ["Content-Type", "Authorization"],
                credentials: options && options.credentials ? options.credentials : false,
                maxAge: options && options.maxAge ? options.maxAge : 86400,
                preflightContinue: options && options.preflightContinue ? options.preflightContinue : false
            }
        } else if (key == "helmet") {
            return {
                contentSecurityPolicy: options && options.contentSecurityPolicy ? options.contentSecurityPolicy : true,
                frameguard: options && options.frameguard ? options.frameguard : true,
                hidePoweredBy: options && options.hidePoweredBy ? options.hidePoweredBy : true,
                noSniff: options && options.noSniff ? options.noSniff : true,
                xssFilter: options && options.xssFilter ? options.xssFilter : true
            }
        } else if (key == "compression") {
            return {
                level: options && options.level ? options.level : 6,
                threshold: options && options.threshold ? options.threshold : 1024,
                filter: options && options.filter ? options.filter : null
            }
        } else if (key == "rateLimit") {
            return {
                windowMs: options && options.windowMs ? options.windowMs : 900000,
                max: options && options.max ? options.max : 100,
                message: options && options.message ? options.message : "Too many requests"
            }
        } else if (key == "staticFiles") {
            return {
                index: options && options.index ? options.index : "index.html",
                dotfiles: options && options.dotfiles ? options.dotfiles : "ignore",
                etag: options && options.etag ? options.etag : true,
                extensions: options && options.extensions ? options.extensions : false,
                fallthrough: options && options.fallthrough ? options.fallthrough : true,
                immutable: options && options.immutable ? options.immutable : false,
                lastModified: options && options.lastModified ? options.lastModified : true,
                maxAge: options && options.maxAge ? options.maxAge : 0,
                redirect: options && options.redirect ? options.redirect : true,
                setHeaders: options && options.setHeaders ? options.setHeaders : null
            }
        }
        
        return {}
    }

    // Advanced middleware
    soul cors(options, app) {
        corsConfig = this.mergeWithDefaults("cors", options)
        
        corsMiddleware = soul(req, res, next) {
            // Set CORS headers
            res.header("Access-Control-Allow-Origin", corsConfig.origin)
            res.header("Access-Control-Allow-Methods", corsConfig.methods.join(","))
            res.header("Access-Control-Allow-Headers", corsConfig.headers.join(","))
            
            if (corsConfig.credentials) {
                res.header("Access-Control-Allow-Credentials", "true")
            }
            
            if (corsConfig.maxAge) {
                res.header("Access-Control-Max-Age", corsConfig.maxAge.toString())
            }
            
            if (req.method == "OPTIONS") {
                if (corsConfig.preflightContinue) {
                    next()
                } else {
                    res.status(204).end()
                }
            } else {
                next()
            }
        }
        this.middlewares.push({
            path: "*",
            handler: corsMiddleware,
            type: "middleware"
        })
        return app
    }

    soul helmet(options, app) {
        helmetConfig = this.mergeWithDefaults("helmet", options)
        
        helmetMiddleware = soul(req, res, next) {
            if (helmetConfig.hidePoweredBy) {
                res.removeHeader("X-Powered-By")
            }
            
            if (helmetConfig.frameguard) {
                res.header("X-Frame-Options", "DENY")
            }
            
            if (helmetConfig.noSniff) {
                res.header("X-Content-Type-Options", "nosniff")
            }
            
            if (helmetConfig.xssFilter) {
                res.header("X-XSS-Protection", "1; mode=block")
            }
            
            if (helmetConfig.contentSecurityPolicy) {
                res.header("Content-Security-Policy", "default-src 'self'")
            }
            
            next()
        }
        this.middlewares.push({
            path: "*",
            handler: helmetMiddleware,
            type: "middleware"
        })
        return app
    }

    soul compression(options, app) {
        compressConfig = this.mergeWithDefaults("compression", options)
        
        compressionMiddleware = soul(req, res, next) {
            // Basic compression middleware
            acceptEncoding = req.headers["Accept-Encoding"] || ""
            
            if (acceptEncoding.includes("gzip")) {
                res.header("Content-Encoding", "gzip")
                res.header("Vary", "Accept-Encoding")
            }
            
            next()
        }
        this.middlewares.push({
            path: "*",
            handler: compressionMiddleware,
            type: "middleware"
        })
        return app
    }

    soul rateLimit(options, app) {
        limitConfig = this.mergeWithDefaults("rateLimit", options)
        
        requests = {}
        
        rateLimitMiddleware = soul(req, res, next) {
            key = req.ip ? req.ip : "unknown"
            now = time.now()
            
            if (!requests[key]) {
                requests[key] = {
                    count: 0,
                    resetTime: now + limitConfig.windowMs
                }
            }
            
            if (now > requests[key].resetTime) {
                requests[key].count = 0
                requests[key].resetTime = now + limitConfig.windowMs
            }
            
            requests[key].count++
            
            if (requests[key].count > limitConfig.max) {
                res.status(429).json({
                    error: "Too Many Requests",
                    message: limitConfig.message
                })
                return
            }
            
            next()
        }
        this.middlewares.push({
            path: "*",
            handler: rateLimitMiddleware,
            type: "middleware"
        })
        return app
    }

    // Authentication middleware
    soul auth(strategy, options, app) {
        authConfig = {
            strategy: strategy,
            options: options || {}
        }
        
        if (strategy == "jwt") {
            jwtMiddleware = soul(req, res, next) {
                token = req.headers["authorization"]
                
                if (!token) {
                    return res.status(401).json({
                        error: "Unauthorized",
                        message: "No token provided"
                    })
                }
                
                if (token.startsWith("Bearer ")) {
                    token = token.slice(7)
                }
                
                // JWT verification would go here
                // For now, just pass through
                req.user = { id: 1, username: "user" }
                next()
            }
            this.middlewares.push({
                path: "*",
                handler: jwtMiddleware,
                type: "middleware"
            })
            return app
        } else if (strategy == "basic") {
            basicMiddleware = soul(req, res, next) {
                auth = req.headers["authorization"]
                
                if (!auth || !auth.startsWith("Basic ")) {
                    return res.status(401).json({
                        error: "Unauthorized",
                        message: "Basic authentication required"
                    })
                }
                
                // Basic auth verification would go here
                req.user = { id: 1, username: "user" }
                next()
            }
            this.middlewares.push({
                path: "*",
                handler: basicMiddleware,
                type: "middleware"
            })
            return app
        } else if (strategy == "session") {
            sessionMiddleware = soul(req, res, next) {
                sessionId = req.cookies["session-id"]
                
                if (!sessionId) {
                    return res.status(401).json({
                        error: "Unauthorized",
                        message: "No session found"
                    })
                }
                
                // Session verification would go here
                req.user = { id: 1, username: "user" }
                next()
            }
            this.middlewares.push({
                path: "*",
                handler: sessionMiddleware,
                type: "middleware"
            })
            return app
        }
        
        return app
    }

    // Validation middleware
    soul validate(schema) {
        return soul(req, res, next) {
            errors = this.validateRequest(req, schema)
            
            if (errors.length() > 0) {
                return res.status(400).json({
                    error: "Validation Error",
                    details: errors
                })
            }
            
            next()
        }
    }

    soul validateRequest(req, schema) {
        errors = []
        
        if (schema.body) {
            bodyErrors = this.validateObject(req.body, schema.body, "body")
            for (i = 0; i < bodyErrors.length(); i = i + 1) {
                errors.push(bodyErrors[i])
            }
        }
        
        if (schema.params) {
            paramErrors = this.validateObject(req.params, schema.params, "params")
            for (i = 0; i < paramErrors.length(); i = i + 1) {
                errors.push(paramErrors[i])
            }
        }
        
        if (schema.query) {
            queryErrors = this.validateObject(req.query, schema.query, "query")
            for (i = 0; i < queryErrors.length(); i = i + 1) {
                errors.push(queryErrors[i])
            }
        }
        
        if (schema.headers) {
            headerErrors = this.validateObject(req.headers, schema.headers, "headers")
            for (i = 0; i < headerErrors.length(); i = i + 1) {
                errors.push(headerErrors[i])
            }
        }
        
        return errors
    }

    soul validateObject(obj, schema, path) {
        errors = []
        
        for (field in schema) {
            fieldSchema = schema[field]
            value = obj[field]
            
            if (fieldSchema.required && (value == null || value == null)) {
                errors.push({
                    field: path + "." + field,
                    message: "Field is required"
                })
                // Skip to next field
            }
            
            if (value != null && fieldSchema.type) {
                // Simplified type checking for Soul language
                validType = true
                if (fieldSchema.type == "string" && value.constructor.name != "String") {
                    validType = false
                    errors.push({
                        field: path + "." + field,
                        message: "Must be a string"
                    })
                }
                if (fieldSchema.type == "number" && value.constructor.name != "Number") {
                    validType = false
                    errors.push({
                        field: path + "." + field,
                        message: "Must be a number"
                    })
                }
            }
            
            if (value != null && fieldSchema.min != null && value < fieldSchema.min) {
                errors.push({
                    field: path + "." + field,
                    message: "Must be at least " + fieldSchema.min
                })
            }
            
            if (value != null && fieldSchema.max != null && value > fieldSchema.max) {
                errors.push({
                    field: path + "." + field,
                    message: "Must be at most " + fieldSchema.max
                })
            }
            
            if (value != null && fieldSchema.pattern && !fieldSchema.pattern.test(value)) {
                errors.push({
                    field: path + "." + field,
                    message: "Invalid format"
                })
            }
        }
        
        return errors
    }

    // Static file serving
    soul static(path, options, app) {
        staticConfig = this.mergeWithDefaults("staticFiles", options)
        staticConfig.path = path
        
        staticMiddleware = soul(req, res, next) {
            filePath = req.path.replace(path, "")
            
            if (filePath.startsWith("/")) {
                filePath = filePath.slice(1)
            }
            
            if (!filePath && staticConfig.index) {
                filePath = staticConfig.index
            }
            
            // Static file serving logic would go here
            // For now, just pass through
            next()
        }
        this.middlewares.push({
            path: "*",
            handler: staticMiddleware,
            type: "middleware"
        })
        return app
    }

    // Error handling
    soul error(handler, app) {
        this.errorHandlers.push(handler)
        return app
    }
}