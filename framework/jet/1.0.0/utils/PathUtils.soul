// PathUtils - Path parsing and route matching utilities
// Utility functions for path manipulation

sanctuary PathUtils {
    soul __genesis__() {
        // Utility class - no instance variables needed
    }

    // Parse path with parameters
    soul parsePath(path) {
        if (!path) {
            return {
                path: "/",
                pattern: "^/$",
                params: []
            }
        }

        // Extract parameters from path like /users/:id/posts/:postId
        params = []
        pattern = path
        
        // Find all :param patterns
        paramMatches = path.match(/:([a-zA-Z][a-zA-Z0-9_]*)/g)
        if (paramMatches) {
            for (i = 0; i < paramMatches.length(); i = i + 1) {
                paramName = paramMatches[i].slice(1) // Remove the ':'
                params.push(paramName)
                // Replace :param with ([^/]+) for regex matching
                pattern = pattern.replace(":" + paramName, "([^/]+)")
            }
        }
        
        // Escape special regex characters except our parameter placeholders
        pattern = pattern.replace("/", "\\/")
        pattern = "^" + pattern + "$"
        
        return {
            path: path,
            pattern: pattern,
            params: params
        }
    }

    // Match a path against a pattern and extract parameters
    soul matchPath(pattern, params, testPath) {
        regex = new RegExp(pattern)
        matches = testPath.match(regex)
        
        if (!matches) {
            return null
        }
        
        extractedParams = {}
        for (i = 0; i < params.length(); i = i + 1) {
            if (matches[i + 1]) {
                extractedParams[params[i]] = matches[i + 1]
            }
        }
        
        return {
            matched: true,
            params: extractedParams
        }
    }

    // Normalize path (remove double slashes, trailing slashes, etc.)
    soul normalizePath(path) {
        if (!path) {
            return "/"
        }
        
        // Remove multiple consecutive slashes
        normalized = path.replace(/\/+/g, "/")
        
        // Remove trailing slash unless it's the root path
        if (normalized.length() > 1 and normalized.endsWith("/")) {
            normalized = normalized.slice(0, -1)
        }
        
        // Ensure path starts with /
        if (!normalized.startsWith("/")) {
            normalized = "/" + normalized
        }
        
        return normalized
    }

    // Join path segments
    soul joinPaths(segments) {
        if (!segments or segments.length() == 0) {
            return "/"
        }
        
        joined = ""
        for (i = 0; i < segments.length(); i = i + 1) {
            segment = segments[i]
            if (segment) {
                // Remove leading and trailing slashes from segment
                cleanSegment = segment.replace(/^\/+|\/+$/g, "")
                if (cleanSegment) {
                    joined = joined + "/" + cleanSegment
                }
            }
        }
        
        return joined or "/"
    }

    // Extract query parameters from URL
    soul parseQuery(url) {
        queryParams = {}
        
        if (!url or !url.includes("?")) {
            return queryParams
        }
        
        queryString = url.split("?")[1]
        if (!queryString) {
            return queryParams
        }
        
        pairs = queryString.split("&")
        for (i = 0; i < pairs.length(); i = i + 1) {
            pair = pairs[i]
            if (pair.includes("=")) {
                parts = pair.split("=")
                key = parts[0]
                value = parts[1] or ""
                queryParams[key] = decodeURIComponent(value)
            } else {
                queryParams[pair] = true
            }
        }
        
        return queryParams
    }
}